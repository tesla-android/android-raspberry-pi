From e0fd1941735e457c4bd5b96777e37b94e396d582 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Micha=C5=82=20Gapi=C5=84ski?= <mike@gapinski.eu>
Date: Tue, 6 Feb 2024 20:01:22 +0000
Subject: [PATCH 1/6] Add Virtual Touchscreen

---
 drivers/input/touchscreen/Kconfig             |   6 +
 drivers/input/touchscreen/Makefile            |   1 +
 .../input/touchscreen/virtual_touchscreen.c   | 237 ++++++++++++++++++
 3 files changed, 244 insertions(+)
 create mode 100644 drivers/input/touchscreen/virtual_touchscreen.c

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index dc90a3ea5..e4c7fd160 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -12,6 +12,12 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
+config TOUCHSCREEN_VIRTUAL
+	tristate "Enable TOUCHSCREEN_VIRTUAL"
+	default m
+	help
+	  Simple virtual input device for testing things in Linux. Creates a character device and an input device.
+
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 557f84fd2..095dec637 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -8,6 +8,7 @@
 wm97xx-ts-y := wm97xx-core.o
 goodix_ts-y := goodix.o goodix_fwupload.o
 
+obj-$(CONFIG_TOUCHSCREEN_VIRTUAL)	+= virtual_touchscreen.o
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
diff --git a/drivers/input/touchscreen/virtual_touchscreen.c b/drivers/input/touchscreen/virtual_touchscreen.c
new file mode 100644
index 000000000..f84c5f051
--- /dev/null
+++ b/drivers/input/touchscreen/virtual_touchscreen.c
@@ -0,0 +1,237 @@
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+#include <asm/uaccess.h>
+
+#define MODNAME "virtual_touchscreen"
+
+#define ABS_X_MIN	0
+#define ABS_Y_MIN	0
+
+#define MAX_CONTACTS 10    // 10 fingers is it
+
+#define DEVICE_NAME "virtual_touchscreen"
+static int device_open(struct inode *, struct file *);
+static int device_release(struct inode *, struct file *);
+static ssize_t device_read(struct file *, char *, size_t, loff_t *);
+static ssize_t device_write(struct file *, const char *, size_t, loff_t *);
+
+static int Major;            /* Major number assigned to our device driver */
+static int Device_Open = 0;  /* Is device open?  Used to prevent multiple access to the device */
+
+static int ABS_X_MAX = 1024;
+static int ABS_Y_MAX = 768;
+
+struct class * cl;
+struct device * dev;
+
+struct file_operations fops __attribute__((__section__(".text"))) = {
+       read: device_read,
+       write: device_write,
+       open: device_open,
+       release: device_release
+};
+
+static struct input_dev *virt_ts_dev;
+
+static int __init virt_ts_init(void)
+{
+	int err;
+
+	virt_ts_dev = input_allocate_device();
+	if (!virt_ts_dev)
+		return -ENOMEM;
+
+	virt_ts_dev->evbit[0] = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);
+	virt_ts_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(virt_ts_dev, ABS_X, ABS_X_MIN, ABS_X_MAX, 0, 0);
+	input_set_abs_params(virt_ts_dev, ABS_Y, ABS_Y_MIN, ABS_Y_MAX, 0, 0);
+
+	virt_ts_dev->name = "Virtual touchscreen";
+	virt_ts_dev->phys = "virtual_ts/input0";
+
+        input_mt_init_slots(virt_ts_dev, MAX_CONTACTS, INPUT_MT_DIRECT);
+
+	input_set_abs_params(virt_ts_dev, ABS_MT_POSITION_X, ABS_X_MIN, ABS_X_MAX, 0, 0);
+	input_set_abs_params(virt_ts_dev, ABS_MT_POSITION_Y, ABS_Y_MIN, ABS_Y_MAX, 0, 0);
+
+	err = input_register_device(virt_ts_dev);
+	if (err)
+		goto fail1;
+
+
+    /* Above is evdev part. Below is character device part */
+
+    Major = register_chrdev(0, DEVICE_NAME, &fops);
+    if (Major < 0) {
+	printk ("Registering the character device failed with %d\n", Major);
+	    goto fail1;
+    }
+    printk ("virtual_touchscreen: Major=%d\n", Major);
+
+    cl = class_create(THIS_MODULE, DEVICE_NAME);
+    if (!IS_ERR(cl)) {
+	    dev = device_create(cl, NULL, MKDEV(Major,0), NULL, DEVICE_NAME);
+    }
+
+
+	return 0;
+
+ fail1:	input_free_device(virt_ts_dev);
+	return err;
+}
+
+static int device_open(struct inode *inode, struct file *file) {
+    if (Device_Open) return -EBUSY;
+    ++Device_Open;
+    return 0;
+}
+
+static int device_release(struct inode *inode, struct file *file) {
+    --Device_Open;
+    return 0;
+}
+
+static ssize_t device_read(struct file *filp, char *buffer, size_t length, loff_t *offset) {
+    const char* message =
+        "Usage: write the following commands to /dev/virtual_touchscreen:\n"
+        "    x num  - move to (x, ...)\n"
+        "    y num  - move to (..., y)\n"
+        "    d 0    - touch down\n"
+        "    u 0    - touch up\n"
+        "    s slot - select multitouch slot (0 to 9)\n"
+        "    a flag - report if the selected slot is being touched\n"
+        "    e 0   - trigger input_mt_report_pointer_emulation\n"
+        "    X num - report x for the given slot\n"
+        "    Y num - report y for the given slot\n"
+        "    S 0   - sync (should be after every block of commands)\n"
+        "    M 0   - multitouch sync\n"
+        "    T num - tracking ID\n"
+        "    also 0123456789:; - arbitrary ABS_MT_ command (see linux/input.h)\n"
+        "  each command is char and int: sscanf(\"%c%d\",...)\n"
+        "  <s>x and y are from 0 to 1023</s> Probe yourself range of x and y\n"
+        "  Each command is terminated with '\\n'. Short writes == dropped commands.\n"
+        "  Read linux Documentation/input/multi-touch-protocol.txt to read about events\n";
+    const size_t msgsize = strlen(message);
+    loff_t off = *offset;
+    if (off >= msgsize) {
+        return 0;
+    }
+    if (length > msgsize - off) {
+        length = msgsize - off;
+    }
+    if (copy_to_user(buffer, message+off, length) != 0) {
+        return -EFAULT;
+    }
+
+    *offset+=length;
+    return length;
+}
+
+static void execute_command(char command, int arg1) {
+    switch(command) {
+        case 'x':
+            input_report_abs(virt_ts_dev, ABS_X, arg1);
+            break;
+        case 'y':
+            input_report_abs(virt_ts_dev, ABS_Y, arg1);
+            break;
+        case 'd':
+            input_report_key(virt_ts_dev, BTN_TOUCH, 1);
+            break;
+        case 'u':
+            input_report_key(virt_ts_dev, BTN_TOUCH, 0);
+            break;
+
+        case 's':
+            input_mt_slot(virt_ts_dev, arg1);
+            break;
+        case 'a':
+            input_mt_report_slot_state(virt_ts_dev, MT_TOOL_FINGER, arg1);
+            break;
+        case 'e':
+            input_mt_report_pointer_emulation(virt_ts_dev, true);
+            break;
+        case 'X':
+            input_event(virt_ts_dev, EV_ABS, ABS_MT_POSITION_X, arg1);
+            break;
+        case 'Y':
+            input_event(virt_ts_dev, EV_ABS, ABS_MT_POSITION_Y, arg1);
+            break;
+
+        case 'S':
+	        input_sync(virt_ts_dev);
+            break;
+        case 'M':
+            input_mt_sync(virt_ts_dev);
+            break;
+        case 'T':
+            input_event(virt_ts_dev, EV_ABS, ABS_MT_TRACKING_ID, arg1);
+            break;
+        default:
+            if ((command>=0x30) && (command<=0x3b)) {
+                input_event(virt_ts_dev, EV_ABS, command, arg1);
+            } else {
+                printk("<4>virtual_touchscreen: Unknown command %c with arg %d\n", command, arg1);
+            }
+    }
+}
+
+static ssize_t device_write(struct file *filp, const char *buff, size_t len, loff_t *off) {
+    char command;
+    int arg1;
+
+    char buf[64];
+    size_t len_to_use = len;
+    size_t i;
+    size_t p=0;
+
+    if (len_to_use > sizeof(buf)) len_to_use = sizeof(buf);
+
+    if (copy_from_user(buf, buff, len_to_use) != 0) {
+        return -EFAULT;
+    }
+    for(i=0; i<len_to_use; ++i) {
+        if (buf[i]=='\n') {
+            buf[i] = '\0';
+            if(sscanf(buf+p, "%c%d", &command, &arg1) != 2) {
+                printk("<4>virtual_touchscreen: sscanf failed to interpret this input\n");
+            }
+            p=i+1;
+            execute_command(command, arg1);
+        }
+    }
+    if (p == 0 && len != 0) {
+        printk("<4>virtual_touchscreen: Command incomplete or too long. Trailing \\n is required.\n");
+        // prevent endless loop
+        return len;
+    }
+
+    return p;
+}
+
+static void __exit virt_ts_exit(void)
+{
+	input_unregister_device(virt_ts_dev);
+
+    if (!IS_ERR(cl)) {
+	    device_destroy(cl, MKDEV(Major,0));
+	    class_destroy(cl);
+    }
+    unregister_chrdev(Major, DEVICE_NAME);
+}
+
+module_init(virt_ts_init);
+module_exit(virt_ts_exit);
+
+MODULE_AUTHOR("Vitaly Shukela(vi0oss@gmail.com, Michał Gapiński (Tesla Android Project)");
+MODULE_DESCRIPTION("Virtual touchscreen driver");
+MODULE_PARM_DESC(ABS_X_MAX, "Maximum X coordinate for touchscreen");
+MODULE_PARM_DESC(ABS_Y_MAX, "Maximum Y coordinate for touchscreen");
+MODULE_LICENSE("GPL");
-- 
2.34.1

